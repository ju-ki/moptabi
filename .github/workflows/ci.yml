name: CI

on:
  push:
    branches:
      - feature**
      - fix**
      - dev
  pull_request:
    branches:
      - dev
      - master

jobs:
  frontend:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    defaults:
      run:
        working-directory: ./frontend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run Prettier check
        run: npm run format:check

      - name: Run Tests
        run: npm run test:coverage

      - name: 'Report Coverage'
        if: always()
        uses:  davelosert/vitest-coverage-report-action@v2
        with:
          working-directory: ./frontend
          json-summary-path: './coverage/coverage-summary.json'
          json-final-path: './coverage/coverage-final.json'
          name: 'Frontend'
  backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    services:
      test-db:
        image: postgres:15
        env:
          POSTGRES_USER: travel_user_test
          POSTGRES_PASSWORD: travel_admin_test
          POSTGRES_DB: ai_travel_test
        ports:
          - 5433:5432
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Create test env
        env:
          TEST_DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
        run: |
          # Create base .env.test if TEST_DATABASE_URL provided
          if [ -n "$TEST_DATABASE_URL" ]; then
            echo "DATABASE_URL=$TEST_DATABASE_URL" > .env.test
          fi
          # Always write Clerk keys; use placeholder if secret not set so app/tests that expect the keys won't crash
          if [ -n "$CLERK_SECRET_KEY" ]; then
            echo "CLERK_SECRET_KEY=$CLERK_SECRET_KEY" >> .env.test
          else
            echo "CLERK_SECRET_KEY=__DUMMY_CLERK_SECRET__" >> .env.test
          fi
          if [ -n "$CLERK_PUBLISHABLE_KEY" ]; then
            echo "CLERK_PUBLISHABLE_KEY=$CLERK_PUBLISHABLE_KEY" >> .env.test
          else
            echo "CLERK_PUBLISHABLE_KEY=__DUMMY_CLERK_PUBLISHABLE__" >> .env.test
          fi
          echo "NODE_ENV=test" >> .env.test

      - name: Install dependencies
        run: bun install

      - name: Run ESLint
        run: bun run lint

      - name: Run Prettier check
        run: bun run format:check

      - name: Setup Node for parsing
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Create test env (override for service host)
        env:
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
        run: |
          # When using GitHub Actions services, the DB is reachable at localhost on the mapped port (5433)
          echo "DATABASE_URL=postgresql://travel_user_test:travel_admin_test@localhost:5433/ai_travel_test?schema=public" > .env.test
          # Preserve or set Clerk keys so tests depending on them do not crash
          if [ -n "$CLERK_SECRET_KEY" ]; then
            echo "CLERK_SECRET_KEY=$CLERK_SECRET_KEY" >> .env.test
          else
            echo "CLERK_SECRET_KEY=__DUMMY_CLERK_SECRET__" >> .env.test
          fi
          if [ -n "$CLERK_PUBLISHABLE_KEY" ]; then
            echo "CLERK_PUBLISHABLE_KEY=$CLERK_PUBLISHABLE_KEY" >> .env.test
          else
            echo "CLERK_PUBLISHABLE_KEY=__DUMMY_CLERK_PUBLISHABLE__" >> .env.test
          fi
          echo "NODE_ENV=test" >> .env.test

      - name: Wait for Postgres to be ready
        run: |
          echo "Waiting for Postgres on localhost:5433..."
          for i in {1..30}; do
            if nc -z localhost 5433; then
              echo "Postgres is up"
              exit 0
            fi
            echo "Postgres not ready yet, retrying... ($i)"
            sleep 2
          done
          echo "Postgres did not become ready in time" >&2
          exit 1

      - name: Generate Prisma Client for test DB
        env:
          DATABASE_URL: postgresql://travel_user_test:travel_admin_test@localhost:5433/ai_travel_test?schema=public
        run: |
          bunx prisma generate
          bunx prisma migrate dev --name test_init

      - name: Create Coverage Directory
        run: mkdir -p ./coverage
      - name: Run Tests (capture exit code)
        run: |
          set -o pipefail
          # Run tests with junit reporter and capture output; ensure junit file is produced under ./junit-report.xml
          bun run test:coverage 2>&1 | tee backend-test.log
          TEST_EXIT=${PIPESTATUS[0]}
          echo "TEST_EXIT=$TEST_EXIT" > test-exit-code.txt
          # propagate original test exit code so job still fails when tests fail
          exit $TEST_EXIT
        continue-on-error: true

      - name: Upload junit artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-junit
          path: backend/coverage/junit.xml

      - name: 'Report Coverage'
        if: ${{ github.event_name == 'pull_request' }}
        uses: romeovs/lcov-reporter-action@v0.2.16
        with:
          github-token: ${{ secrets.ACTION_TOKEN }}
          lcov-file: backend/coverage/lcov.info

      - name: Post or update PR comment with test summary
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ACTION_TOKEN }}
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;

            // Read test exit code if available (file lives under backend/)
            let testExit = 0;
            try {
              const exitPath = 'backend/test-exit-code.txt';
              if (fs.existsSync(exitPath)) {
                testExit = Number(fs.readFileSync(exitPath, 'utf8').trim()) || 0;
              }
            } catch (e) {
              testExit = 1;
            }

            // Parse junit XML (backend/coverage/junit.xml) for totals
            let totals = { tests: 0, failures: 0, errors: 0, skipped: 0, time: 0 };
            try {
              const junitPath = 'backend/coverage/junit.xml';
              if (fs.existsSync(junitPath)) {
                const xml = fs.readFileSync(junitPath, 'utf8');
                // Sum attributes from <testsuite ...> entries
                const suiteRe = /<testsuite\b([^>]*)>/g;
                let m;
                while ((m = suiteRe.exec(xml)) !== null) {
                  const attrs = m[1];
                  const getAttr = (name) => {
                    const r = new RegExp(name + '="([0-9.]+)"');
                    const mm = attrs.match(r);
                    return mm ? Number(mm[1]) : 0;
                  };
                  totals.tests += getAttr('tests');
                  totals.failures += getAttr('failures');
                  totals.errors += getAttr('errors');
                  totals.skipped += getAttr('skipped');
                  totals.time += getAttr('time');
                }
                // Fallback: look for top-level <testsuites ...>
                if (totals.tests === 0) {
                  const topRe = /<testsuites\b([^>]*)>/;
                  const top = xml.match(topRe);
                  if (top) {
                    const attrs = top[1];
                    const getAttrTop = (name) => {
                      const r = new RegExp(name + '="([0-9.]+)"');
                      const mm = attrs.match(r);
                      return mm ? Number(mm[1]) : 0;
                    };
                    totals.tests = getAttrTop('tests');
                    totals.failures = getAttrTop('failures');
                    totals.errors = getAttrTop('errors');
                    totals.skipped = getAttrTop('skipped');
                    totals.time = getAttrTop('time');
                  }
                }
              }
            } catch (e) {
              // ignore parse errors
            }


            const passed = testExit === 0 && totals.failures === 0 && totals.errors === 0;

            const lines = [];
            lines.push('## Backend Test Report');
            lines.push('');
            lines.push(`**Status:** ${passed ? '‚úÖ Passed' : '‚ùå Failed'}`);
            lines.push('');

            const body = lines.join('\n');

            // Find existing bot comment
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: prNumber });
            const marker = '<!-- ai-travel-planner-test-report -->';
            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
            }

      - name: Build
        run: bun run build

  create-pull-request:
    if: github.event_name == 'push'
    needs: [frontend, backend]
    runs-on: ubuntu-latest
    steps:
      - name: Install GitHub CLI
        run: sudo apt-get install -y gh

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Check and Create Pull Request
        id: create-pr
        env:
          GH_TOKEN: ${{ secrets.ACTION_TOKEN }}
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [ "$CURRENT_BRANCH" != "dev" ]; then
            # Êó¢Â≠ò„ÅÆPR„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            EXISTING_PR=$(gh pr list --head "$CURRENT_BRANCH" --base dev --json number --jq '.[0].number')
            if [ -n "$EXISTING_PR" ]; then
              echo "Êó¢Â≠ò„ÅÆPR„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü: #$EXISTING_PR"
              echo "pr_url=$(gh pr view $EXISTING_PR --json url --jq .url)" >> $GITHUB_OUTPUT
              exit 0
            fi

            PR_URL=$(gh pr create \
              --base dev \
              --head "$CURRENT_BRANCH" \
              --title "ü§ñ [Auto] $COMMIT_MESSAGE" \
              --body "## Ëá™ÂãïÁîüÊàê„Åï„Çå„ÅüPR
              „Åì„ÅÆPR„ÅØGitHub Actions„Å´„Çà„Å£„Å¶Ëá™ÂãïÁöÑ„Å´‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü„ÄÇ

              ### Â§âÊõ¥ÂÜÖÂÆπ
              ${COMMIT_MESSAGE}

              ### „É¨„Éì„É•„Éº‰æùÈ†º
              @coderabbitai review")
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
            echo "PR created at $PR_URL"
          else
            echo "pr_url=" >> $GITHUB_OUTPUT
            echo "No changes to create a PR for."
          fi
